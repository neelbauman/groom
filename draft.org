-*- mode:org; -*-

* GROOM ver1.0
** modius operandi with org-mode
Groomとは、よく組織化されかつ自由な作業環境を実現するために、タスクマネジメント（TM）とオーサリング（AT）に対して定められた一貫性のある様式のことである。

** パラダイム
*** タスクとはなにか
タスクとは、状況から引き出されるべきアクションの定式化のことである。
変化する状況によく追随して常に再生成される最善のアクションの優先順位つきリストがあれば、
我々は投げ入れられている状況に飲み込まれず、その波を乗りこなしていると言える。

状況が常に可変なものであるから、タスクも常に可変でなくてはならない。


したがって、タスクの制御フローが柔軟でロバストなものであれば、急速で複雑な状況の変化にも
よく追随し、しかし破綻しないタスク制御が可能になる。
- なるべく問題が発生しないようにし、問題が発生した場合は適切に処理する
そもそも仕事の一連の流れとは、状況を望んだ方向へと変化させるためのものであり、
仕事の本質とは状況の変化を生み出し、受け入れ、コントロールしようと試みることであるとさえ言える。

**** タスクに要求される性質
- 可塑性
- 記録性

*** 報告・連絡・相談
- 報告 :: report
- 連絡 :: brief
- 相談 :: ask, discuss, negotiate,

share, convey

*** カプセル化
**** タスクかタスクでないか

-----
task（状況が誘起するTODO）
- habit的なタスク（長寿）
  + homeでのタスク
  + officeでのタスク
- agenda的なタスク（典型）
  + プロジェクトA
  + プロジェクトB
- instant的なタスク（短命）
  + 一時的な伝達事項
  + イベント事

-----
non-task（状況非依存）
- usual
- routine

*** 公私混同
Groomは、仕事とプライベートを分離しない。
なぜなら、仕事とプライベートは区別できるものではないから。
それらをまとめて取り扱って初めて良い生き方ができるというものだ。






*** 生活の仕方は脚本のようなものだ                                  :ARCHIVE:
**** 脚本は1つとは限らない
*** そして、脚本は推敲を重ねて書き換えられていくものだ              :ARCHIVE:
**** 推敲されるためには、”書き出されていなければならない”
**** 良い推敲をするためには、良い道具と適切なやり方を知る必要がある


** 定義
*** ディレクトリ構造
#+begin_src sh :results output :exports results
    echo "Directory Structure:"
    tree -d ~/org/
#+end_src
 /home/adelie/org
 ├── agenda.org
 ├── archive
 │   ├── archive.org
 │   ├── draft.org_archive
 │   ├── graphpaper.org_archive
 │   └── readiness.org_archive
 ├── graphpaper.org
 ├── habit.org
 ├── model
 │   └── script.org
 └── note
     ├── helloworld.udemy.org
     ├── latex.org
     ├── ltximg
     │   ├── org-ltximg_00b652ea310bf87ac4ce016143b9d793bae6a845.svg
     │   ├── org-ltximg_fe5af96d39cff44b8a5401db006ce276e645f96a.svg
     │   └── org-ltximg_fe606b79b2553766f762fe189b91d241aae20379.svg
     ├── pumlimg
     │   ├── condisional_independence.png
     │   ├── independence.png
     │   └── independence.svg
     ├── readiness.org
     └── set_theory.org

* トピックごとにブランチを使い分けたい！
** 理由
*** 特定の期間のみに適用させたいスケジュールもある。
*** デフォルトのスケジュールはもちろん残したい
*** habit機能も使いたい
*** エントリが増えると、重複やなんやかんやでagenda viewが見づらくなる
**** Daily Viewでのフィルタ機能はかゆいところに手が届かない
**** 解決するためにはSexpやLispの勉強をしたり、
**** 同じエントリをいくつもハードコードしなくてはならないらしい

** 

* アイデア
** masterブランチをマスターとして、patchでtopicにキャッチアップさせる!
ポイントは、topicでの編集のうち、
masterに取り込みたくない変更とmasterに取り込みたい変更がある
ということ。
それを、patchファイルを処理することでうまく分別する。

** ワークフロー
*** 作業したいtopicをcheckoutする（トピックAとする）
*** masterにrebaseする
トピックAをチェックアウトして、
直前にチェックアウトされていたトピックBでの進捗がマスターに反映されているとき、
rebaseによってトピックBでの進捗をトピックAに取り込まなければならない
_仮想的に、最新のmasterから新しくトピックAブランチをチェックアウトした_ ように見えるはずである。

トピックAの編集とトピックBでの編集にコンフリクトが起きるならここで解消しなければならないが、
設計上基本的に一貫性のある編集をしているはず。
*** トピックAで作業する
*** トピックAでの編集をcommitする
トピックAにかかずらっている間は、特に何も考えることなくトピックAで作業を継続して良い。

以下のフローは、
+ トピックAを中断してトピックBでスケジュールしたかったり、
+ トピックAが終了して、一度ブランチを閉じるとき
といった場合に必要になる作業である。

*** masterをcheckout
*** topicとmasterのdiffを取って、topic/トピックA.patchに書き出す
この時点で、最新のmasterと最新のtopicとの間のdiff取り出される。
したがって、topicにおける進捗がなくなったとき、topic.patchファイルには
topicからmasterに取り込まれなかった差分のみが残ることになる。
したがって、このmasterを残しておけば、
一度トピックを閉じてブランチを削除したとしても
もう一度同じ名前のブランチを作ってから
そのpatchを適用すれば、最新のmasterからそのtopicのブランチを復元できる。
*** topic/トピックA.patchからmasterに取り込みたい部分だけを抽出して適用
cat topic/topic.patch | sed, awk, grep > tmp.patchを利用
*** masterをcommitする(masterのキャッチアップ)
*** 一番上(topicのcheckout)に戻る


** プロジェクト単位で.orgを生成する
.orgとプロジェクトディレクトリの対応を作ることができる。

** マージではなく、パッチで処理する
なぜなら、.gitattributesでのmerge=ours戦略では、コンフリクト、すなわち共通の祖先に対する矛盾する
編集がぶつかったとき、マージする側の編集内容を採択するため。


** note                                                             :ARCHIVE:
script, scenario, agenda
+ [ ] タスクマネジメント 
  + [ ] 実施実績を記録するべき繰り返しタスク（habit）
  + [ ] 実施実績を残す必要のない繰り返しタスク（routine）
  + [ ] 繰り返しではない日々の生成的なタスク（task）
  + [ ] タスクではないが、繰り返され、毎日のスケジュールの骨子となる行動や時間（frame）
+ [ ] オーサリング
  + [ ] 講座、イベント、議事録など、種々の形式でのノートテイキング
  + [ ] UMLダイアグラムの挿入
  + [ ] $\LaTeX$フラグメントの挿入




